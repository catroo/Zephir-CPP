
/*
 +--------------------------------------------------------------------------+
 | Zephir Language                                                          |
 +--------------------------------------------------------------------------+
 | Copyright (c) 2013-2014 Zephir Team and contributors                     |
 +--------------------------------------------------------------------------+
 | This source file is subject the MIT license, that is bundled with        |
 | this package in the file LICENSE, and is available through the           |
 | world-wide-web at the following url:                                     |
 | http://zephir-lang.com/license.html                                      |
 |                                                                          |
 | If you did not receive a copy of the MIT license and are unable          |
 | to obtain it through the world-wide-web, please send a note to           |
 | license@zephir-lang.com so we can mail you a copy immediately.           |
 +--------------------------------------------------------------------------+
*/

/**
 * Zephir parser
 *
 * This parser is intended to produce a better and safe code generation
 * rather than full expresiveness
 */

%token_prefix XX_
%token_type {xx_parser_token*}
%default_type {Json::Value*}
%extra_argument {xx_parser_status *status}
%name xx_

%left PUBLIC PROTECTED STATIC PRIVATE SCOPED .

%left COMMA .
%right REQUIRE .
%right QUESTION .
%right LIKELY UNLIKELY .
%left INSTANCEOF .
%left OR .
%left AND .
%left BITWISE_OR BITWISE_AND BITWISE_XOR BITWISE_SHIFTLEFT BITWISE_SHIFTRIGHT .
%left EQUALS IDENTICAL LESS GREATER LESSEQUAL GREATEREQUAL NOTIDENTICAL NOTEQUALS .
%left ADD SUB CONCAT .
%left MUL DIV MOD .
%right ISSET FETCH EMPTY .
%right TYPEOF .
%right CLONE .
%right NEW .
%right NOT .
%right PARENTHESES_CLOSE .
%right SBRACKET_OPEN .
%right ARROW .

%include {

#include <iostream>
#include <cstddef>
#include <string>
#include <iostream>

#include "json/json.h"

#include "string.h"
#include "parser.h"
#include "scanner.h"
#include "xx.h"

using namespace std;

static Json::Value* xx_ret_literal(int type, xx_parser_token *T, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	switch (type) {

		case XX_T_CONSTANT:
			(*ret)["type"] = "constant";
			break;

		case XX_T_IDENTIFIER:
			(*ret)["type"] = "variable";
			break;

		case XX_T_INTEGER:
			(*ret)["type"] = "int";
			break;

		case XX_T_DOUBLE:
			(*ret)["type"] = "double";
			break;

		case XX_T_NULL:
			(*ret)["type"] = "null";
			break;

		case XX_T_STRING:
			(*ret)["type"] = "string";
			break;

		case XX_T_CHAR:
			(*ret)["type"] = "char";
			break;

		default:
			if (type == XX_T_TRUE) {
				(*ret)["type"] = "bool";
				(*ret)["value"] = "true";
			} else {
				if (type == XX_T_FALSE) {
					(*ret)["type"] = "bool";
					(*ret)["value"] = "false";
				} else {
					fprintf(stderr, "literal??\n");
				}
			}
	}

	if (T) {
		(*ret)["value"] = T->token;
		delete T;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_expr(const char *type, Json::Value* left, Json::Value* right, Json::Value* extra, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = type;

	if (nullptr != left) {
		(*ret)["left"] = *left;
		delete left;
	}
	if (nullptr != right) {
		(*ret)["right"] = *right;
		delete right;
	}
	if (nullptr != extra) {
		(*ret)["extra"] = *extra;
		delete extra;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_array_item(Json::Value* key, Json::Value* value, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	if (nullptr != key) {
		(*ret)["key"] = key;
		delete key;
	}
	(*ret)["value"] = *value;
	delete value;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_namespace(xx_parser_token *T, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "namespace";
	(*ret)["name"] = T->token;
	delete T;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_use_aliases(Json::Value* use_aliases_list, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "use";
	(*ret)["aliases"] = *use_aliases_list;
	delete use_aliases_list;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_use_aliases_item(xx_parser_token *T, xx_parser_token *A, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["name"] = T->token;
	delete T;
	if (A) {
		(*ret)["alias"] = A->token;
		delete A;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_class(xx_parser_token *T, Json::Value* class_definition, int is_abstract, int is_final,
	xx_parser_token *E, Json::Value* I, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "class";
	(*ret)["name"] = T->token;
	delete T;

	(*ret)["abstract"] = is_abstract;
	(*ret)["final"] = is_final;

	if (E) {
		(*ret)["extends"] = E->token;
		delete E;
	}

	if (nullptr != I) {
		(*ret)["implements"] = *I;
		delete I;
	}

	if (nullptr != class_definition) {
		(*ret)["definition"] = *class_definition;
		delete class_definition;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_interface(xx_parser_token *T, Json::Value* interface_definition, xx_parser_token *E, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "interface";
	(*ret)["name"] = T->token;
	delete T;

	if (E) {
		(*ret)["definition"] = E->token;
		delete E;
	}

	if (nullptr != interface_definition) {
		(*ret)["definition"] = *interface_definition;
		delete interface_definition;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_class_definition(Json::Value* properties, Json::Value* methods, Json::Value* constants, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	if (nullptr != properties) {
		(*ret)["properties"] = *properties;
		delete properties;
	}
	if (nullptr != methods) {
		(*ret)["methods"] = *methods;
		delete methods;
	}
	if (nullptr != constants) {
		(*ret)["constants"] = *constants;
		delete constants;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_interface_definition(Json::Value* methods, Json::Value* constants, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	if (nullptr != methods) {
		(*ret)["methods"] = *methods;
		delete methods;
	}
	if (nullptr != constants) {
		(*ret)["constants"] = *constants;
		delete constants;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_class_property(Json::Value* visibility, xx_parser_token *T,
		Json::Value* default_value, xx_parser_token *D, Json::Value* shortcuts, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["visibility"] = visibility;
	delete visibility;
	(*ret)["property"] = "property";
	(*ret)["name"] = T->token;
	delete T;

	if (nullptr != default_value) {
		(*ret)["default"] = *default_value;
		delete default_value;
	}

	if (D) {
		(*ret)["docblock"] = D->token;
		delete D;
	}

	if (nullptr != shortcuts) {
		(*ret)["shortcuts"] = *shortcuts;
		delete shortcuts;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_property_shortcut(xx_parser_token *C, xx_parser_token *D, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "shortcuts";
	if (C) {
		(*ret)["docblock"] = C->token;
		delete C;
	}
	(*ret)["name"] = D->token;
	delete D;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_class_const(xx_parser_token *T, Json::Value* default_value, xx_parser_token *D, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "const";
	(*ret)["name"] = T->token;
	delete T;
	(*ret)["default"] = default_value;
	delete default_value;

	if (D) {
		(*ret)["docblock"] = D->token;
		delete D;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_class_method(Json::Value* visibility, xx_parser_token *T, Json::Value* parameters,
	Json::Value* statements, xx_parser_token *D, Json::Value* return_type, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["visibility"] = visibility;
	delete visibility;
	(*ret)["type"] = "method";
	(*ret)["name"] = T->token;
	delete T;

	if (nullptr != parameters) {
		(*ret)["parameters"] = *parameters;
		delete parameters;
	}

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}

	if (D) {
		(*ret)["docblock"] = D->token;
		delete D;
	}

	if (nullptr != return_type) {
		(*ret)["return-type"] = *return_type;
		delete return_type;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_parameter(int const_param, Json::Value* type, Json::Value* cast, xx_parser_token *N, Json::Value* default_value,
	int mandatory, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "parameter";
	(*ret)["name"] = N->token;
	delete N;
	(*ret)["const"] = const_param;

	if (nullptr != type) {
		(*ret)["data-type"] = *type;
		(*ret)["mandatory"] = mandatory;
		delete type;
	} else {
		(*ret)["data-type"] = "variable";
		(*ret)["mandatory"] = 0;
	}

	if (nullptr != cast) {
		(*ret)["cast"] = *cast;
		delete cast;
	}
	if (nullptr != default_value) {
		(*ret)["default"] = *default_value;
		delete default_value;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_return_type(int is_void, Json::Value* return_type_list, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "return-type";

	(*ret)["list"] = *return_type_list;
	delete return_type_list;

	(*ret)["void"] = is_void;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_return_type_item(Json::Value* type, Json::Value* cast, int mandatory, int collection, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "return-type-parameter";

	if (nullptr != type) {
		(*ret)["data-type"] = *type;
		(*ret)["mandatory"] = mandatory;
		delete type;
	}

	if (nullptr != cast) {
		(*ret)["cast"] = *cast;
		(*ret)["collection"] = collection;
		delete cast;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_type(int type)
{
	string name;

	switch (type) {
		case XX_TYPE_INTEGER:
			name = "int";
			break;
		case XX_TYPE_UINTEGER:
			name = "uint";
			break;
		case XX_TYPE_DOUBLE:
			name = "double";
			break;
		case XX_TYPE_BOOL:
			name = "bool";
			break;
		case XX_TYPE_LONG:
			name = "long";
			break;
		case XX_TYPE_ULONG:
			name = "ulong";
			break;
		case XX_TYPE_STRING:
			name = "string";
			break;
		case XX_TYPE_CHAR:
			name = "char";
			break;
		case XX_TYPE_ARRAY:
			name = "array";
			break;
		case XX_TYPE_VAR:
			name = "variable";
			break;
		case XX_TYPE_CALLABLE:
			name = "callable";
			break;
		case XX_TYPE_RESOURCE:
			name = "resource";
			break;
		case XX_TYPE_OBJECT:
			name = "object";
			break;
		case XX_T_TYPE_NULL:
			name = "null";
			break;
		case XX_T_TYPE_THIS:
			name = "this";
			break;
		default:
			fprintf(stderr, "unknown type?\n");
	}

	return new Json::Value(name);
}

static Json::Value* xx_ret_list(Json::Value* list_left, Json::Value* right_list)
{
	Json::Value* ret = new Json::Value();
	int i, array_length;

	if (nullptr != list_left) {
		array_length = list_left->size();
		if (array_length > 0) {
			for (i = 0; i < array_length; i++) {
				ret->append((*list_left)[i]);
			}
		} else {
			ret->append(*list_left);
		}
		delete list_left;
	}

	if (nullptr != right_list) {
		ret->append(*right_list);
		delete right_list;
	}

	return ret;
}

static Json::Value* xx_ret_let_statement(Json::Value* assignments, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "let";
	(*ret)["assignments"] = *assignments;
	delete assignments;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_let_assignment(const char *type, Json::Value* op, xx_parser_token *V, xx_parser_token *P, Json::Value* index_expr, Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["assign-type"] = type;
	if (nullptr != op) {
		(*ret)["operator"] = *op;
		delete op;
	}
	(*ret)["variable"] = V->token;
	delete V;
	if (P) {
		(*ret)["property"] = P->token;
		delete P;
	}
	if (nullptr != index_expr) {
		(*ret)["index-expr"] = *index_expr;
		delete index_expr;
	}
	if (nullptr != expr) {
		(*ret)["expr"] = *expr;
		delete expr;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_if_statement(Json::Value* expr, Json::Value* statements, Json::Value* elseif_statements, Json::Value* else_statements, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "if";
	(*ret)["expr"] = *expr;
	delete expr;

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}

	if (nullptr != elseif_statements) {
		(*ret)["elseif_statements"] = *elseif_statements;
		delete elseif_statements;
	}

	if (nullptr != else_statements) {
		(*ret)["else_statements"] = *else_statements;
		delete else_statements;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_switch_statement(Json::Value* expr, Json::Value* clauses, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "switch";
	(*ret)["expr"] = *expr;
	delete expr;

	if (nullptr != clauses) {
		(*ret)["clauses"] = *clauses;
		delete clauses;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_case_clause(Json::Value* expr, Json::Value* statements, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	if (nullptr != expr) {
		(*ret)["type"] = "case";
		(*ret)["expr"] = *expr;
		delete expr;
	} else {
		(*ret)["type"] = "default";
	}

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_while_statement(Json::Value* expr, Json::Value* statements, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "while";
	(*ret)["expr"] = *expr;
	delete expr;

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_do_while_statement(Json::Value* expr, Json::Value* statements, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "do-while";
	(*ret)["expr"] = *expr;
	delete expr;

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_try_catch_statement(Json::Value* statements, Json::Value* catches, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "try-catch";

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}
	if (nullptr != catches) {
		(*ret)["catches"] = *catches;
		delete catches;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_catch_statement(Json::Value* classes, Json::Value* variable, Json::Value* statements, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	if (nullptr != classes) {
		(*ret)["classes"] = *classes;
		delete classes;
	}

	if (nullptr != variable) {
		(*ret)["variable"] = *variable;
		delete variable;
	}

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_for_statement(Json::Value* expr, xx_parser_token *K, xx_parser_token *V, int reverse, Json::Value* statements, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "for";
	(*ret)["expr"] = *expr;
	delete expr;

	if (K) {
		(*ret)["key"] = K->token;
		delete K;
	}
	if (V) {
		(*ret)["value"] = V->token;
		delete V;
	}

	(*ret)["reverse"] = reverse;

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_loop_statement(Json::Value* statements, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "loop";

	if (nullptr != statements) {
		(*ret)["statements"] = *statements;
		delete statements;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_empty_statement(xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "empty";

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_break_statement(xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "break";

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_continue_statement(xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "continue";

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_echo_statement(Json::Value* expressions, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "echo";
	(*ret)["expressions"] = *expressions;
	delete expressions;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_return_statement(Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "return";
	if (nullptr != expr) {
		(*ret)["expr"] = *expr;
		delete expr;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_require_statement(Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "require";
	(*ret)["expr"] = *expr;
	delete expr;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_fetch_statement(Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "fetch";
	(*ret)["expr"] = *expr;
	delete expr;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_fcall_statement(Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "fcall";
	(*ret)["expr"] = *expr;
	delete expr;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_mcall_statement(Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "mcall";
	(*ret)["expr"] = *expr;
	delete expr;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_scall_statement(Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "scall";
	(*ret)["expr"] = *expr;
	delete expr;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_unset_statement(Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "unset";
	(*ret)["expr"] = *expr;
	delete expr;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_declare_statement(int type, Json::Value* variables, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "declare";

	switch (type) {

		case XX_T_TYPE_INTEGER:
			(*ret)["data-type"] = "int";
			break;

		case XX_T_TYPE_UINTEGER:
			(*ret)["data-type"] = "uint";
			break;

		case XX_T_TYPE_LONG:
			(*ret)["data-type"] = "long";
			break;

		case XX_T_TYPE_ULONG:
			(*ret)["data-type"] = "ulong";
			break;

		case XX_T_TYPE_CHAR:
			(*ret)["data-type"] = "char";
			break;

		case XX_T_TYPE_UCHAR:
			(*ret)["data-type"] = "uchar";
			break;

		case XX_T_TYPE_DOUBLE:
			(*ret)["data-type"] = "double";
			break;

		case XX_T_TYPE_BOOL:
			(*ret)["data-type"] = "bool";
			break;

		case XX_T_TYPE_STRING:
			(*ret)["data-type"] = "string";
			break;

		case XX_T_TYPE_ARRAY:
			(*ret)["data-type"] = "array";
			break;

		case XX_T_TYPE_VAR:
			(*ret)["data-type"] = "variable";
			break;

		case XX_T_TYPE_CALLABLE:
			(*ret)["data-type"] = "callable";
			break;

		case XX_T_TYPE_RESOURCE:
			(*ret)["data-type"] = "resource";
			break;

		case XX_T_TYPE_OBJECT:
			(*ret)["data-type"] = "object";
			break;

		default:
			fprintf(stderr, "err 2?\n");
	}

	(*ret)["variables"] = *variables;
	delete variables;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_declare_variable(xx_parser_token *T, Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["variable"] = T->token;
	delete T;
	if (nullptr != expr) {
		(*ret)["expr"] = *expr;
		delete expr;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_new_instance(int dynamic, xx_parser_token *T, Json::Value* parameters, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "new";
	(*ret)["class"] = T->token;
	delete T;
	(*ret)["dynamic"] = dynamic;

	if (nullptr != parameters) {
		(*ret)["parameters"] = *parameters;
		delete parameters;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_throw_exception(Json::Value* expr, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "throw";
	if (nullptr != expr) {
		(*ret)["expr"] = *expr;
		delete expr;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_fcall(int type, xx_parser_token *F, Json::Value* parameters, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "fcall";
	(*ret)["name"] = F->token;
	delete F;
	(*ret)["call-type"] = type;

	if (nullptr != parameters) {
		(*ret)["parameters"] = *parameters;
		delete parameters;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_mcall(int type, Json::Value* O, xx_parser_token *M, Json::Value* parameters, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "mcall";
	(*ret)["variable"] = *O;
	delete O;
	(*ret)["name"] = M->token;
	delete M;
	(*ret)["call-type"] = type;

	if (nullptr != parameters) {
		(*ret)["parameters"] = *parameters;
		delete parameters;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_scall(int dynamic_class, xx_parser_token *O, int dynamic_method, xx_parser_token *M, Json::Value* parameters, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "scall";
	(*ret)["dynamic-class"] = dynamic_class;
	(*ret)["class"] = O->token;
	delete O;
	(*ret)["dynamic"] = dynamic_method;
	(*ret)["name"] = M->token;
	delete M;

	if (nullptr != parameters) {
		(*ret)["parameters"] = *parameters;
		delete parameters;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_call_parameter(xx_parser_token *N, Json::Value* parameter, xx_scanner_state *state, int reference)
{
	Json::Value* ret = new Json::Value();

	if (N) {
		(*ret)["name"] = N->token;
		delete N;
	}
	(*ret)["parameter"] = *parameter;
	delete parameter;
	if (reference) {
		(*ret)["reference"] = reference;
	}

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_comment(xx_parser_token *T, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "comment";
	(*ret)["value"] = T->token;
	delete T;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

static Json::Value* xx_ret_cblock(xx_parser_token *T, xx_scanner_state *state)
{
	Json::Value* ret = new Json::Value();

	(*ret)["type"] = "cblock";
	(*ret)["value"] = T->token;
	delete T;

	(*ret)["file"] = state->active_file;
	(*ret)["line"] = state->active_line;
	(*ret)["char"] = state->active_char;

	return ret;
}

}

%syntax_error {

	//fprintf(stderr, "error!\n");

	Json::Value* syntax_error = new Json::Value();

	(*syntax_error)["type"] = "error";

	//status->syntax_error_len = 48 + Z_STRLEN_P(status->scanner_state->active_file);
	//status->syntax_error = emalloc(sizeof(char) * status->syntax_error_len);

	if (status->scanner_state->start_length) {
		(*syntax_error)["message"] = "Syntax error";
	} else {
		(*syntax_error)["message"] = "Unexpected EOF";
	}

	(*syntax_error)["file"] = status->scanner_state->active_file;
	(*syntax_error)["line"] = status->scanner_state->active_line;
	(*syntax_error)["char"] = status->scanner_state->active_char;

	status->status = XX_PARSING_FAILED;

	status->ret = syntax_error;

	//status->scanner_state->active_file
}

%token_destructor {
	if ($$) {
		if ($$->free_flag) {
			
		}
		delete $$;
	}
}

program ::= xx_language(Q) . {
	status->ret = Q;
}

%destructor xx_language { delete $$; }

xx_language(R) ::= xx_top_statement_list(L) . {
	R = L;
}

xx_top_statement_list(R) ::= xx_top_statement_list(L) xx_top_statement(T) . {
	R = xx_ret_list(L, T);
}

xx_top_statement_list(R) ::= xx_top_statement(T) . {
	R = xx_ret_list(NULL, T);
}

xx_top_statement(R) ::= xx_namespace_def(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_use_aliases(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_class_def(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_interface_def(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_comment(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_cblock(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_let_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_if_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_loop_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_echo_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_return_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_require_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_fetch_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_fcall_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_scall_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_unset_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_throw_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_declare_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_break_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_continue_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_while_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_do_while_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_try_catch_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_switch_statement(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_for_statement(T) . {
	R = T;
}

xx_namespace_def(R) ::= NAMESPACE IDENTIFIER(I) DOTCOMMA . {
	R = xx_ret_namespace(I, status->scanner_state);
}

xx_namespace_def(R) ::= USE xx_use_aliases_list(L) DOTCOMMA . {
	R = xx_ret_use_aliases(L, status->scanner_state);
}

xx_use_aliases_list(R) ::= xx_use_aliases_list(L) COMMA xx_use_aliases(U) . {
	R = xx_ret_list(L, U);
}

xx_use_aliases_list(R) ::= xx_use_aliases(U) . {
	R = xx_ret_list(NULL, U);
}

xx_use_aliases(R) ::= IDENTIFIER(I) . {
	R = xx_ret_use_aliases_item(I, NULL, status->scanner_state);
}

xx_use_aliases(R) ::= IDENTIFIER(I) AS IDENTIFIER(A) . {
	R = xx_ret_use_aliases_item(I, A, status->scanner_state);
}

xx_interface_def(R) ::= INTERFACE IDENTIFIER(I) xx_interface_body(B) . {
	R = xx_ret_interface(I, B, NULL, status->scanner_state);
}

xx_interface_def(R) ::= INTERFACE IDENTIFIER(I) EXTENDS IDENTIFIER(E) xx_interface_body(B) . {
	R = xx_ret_interface(I, B, E, status->scanner_state);
}

xx_class_def(R) ::= CLASS IDENTIFIER(I) xx_class_body(B) . {
	R = xx_ret_class(I, B, 0, 0, NULL, NULL, status->scanner_state);
}

xx_class_def(R) ::= CLASS IDENTIFIER(I) EXTENDS IDENTIFIER(E) xx_class_body(B) . {
	R = xx_ret_class(I, B, 0, 0, E, NULL, status->scanner_state);
}

xx_class_def(R) ::= CLASS IDENTIFIER(I) IMPLEMENTS xx_implements_list(L) xx_class_body(B) . {
	R = xx_ret_class(I, B, 0, 0, NULL, L, status->scanner_state);
}

xx_class_def(R) ::= CLASS IDENTIFIER(I) EXTENDS IDENTIFIER(E) IMPLEMENTS xx_implements_list(L) xx_class_body(B) . {
	R = xx_ret_class(I, B, 0, 0, E, L, status->scanner_state);
}

xx_class_def(R) ::= ABSTRACT CLASS IDENTIFIER(I) xx_class_body(B) . {
	R = xx_ret_class(I, B, 1, 0, NULL, NULL, status->scanner_state);
}

xx_class_def(R) ::= ABSTRACT CLASS IDENTIFIER(I) EXTENDS IDENTIFIER(E) xx_class_body(B) . {
	R = xx_ret_class(I, B, 1, 0, E, NULL, status->scanner_state);
}

xx_class_def(R) ::= ABSTRACT CLASS IDENTIFIER(I) IMPLEMENTS xx_implements_list(L) xx_class_body(B) . {
	R = xx_ret_class(I, B, 1, 0, NULL, L, status->scanner_state);
}

xx_class_def(R) ::= ABSTRACT CLASS IDENTIFIER(I) EXTENDS IDENTIFIER(E) IMPLEMENTS xx_implements_list(L) xx_class_body(B) . {
	R = xx_ret_class(I, B, 1, 0, E, L, status->scanner_state);
}

xx_class_def(R) ::= FINAL CLASS IDENTIFIER(I) xx_class_body(B) . {
	R = xx_ret_class(I, B, 0, 1, NULL, NULL, status->scanner_state);
}

xx_class_def(R) ::= FINAL CLASS IDENTIFIER(I) EXTENDS IDENTIFIER(E) xx_class_body(B) . {
	R = xx_ret_class(I, B, 0, 1, E, NULL, status->scanner_state);
}

xx_class_def(R) ::= FINAL CLASS IDENTIFIER(I) IMPLEMENTS xx_implements_list(L) xx_class_body(B) . {
	R = xx_ret_class(I, B, 0, 1, NULL, L, status->scanner_state);
}

xx_class_body(R) ::= BRACKET_OPEN BRACKET_CLOSE . {
	R = NULL;
}

xx_class_body(R) ::= BRACKET_OPEN xx_class_definition(C) BRACKET_CLOSE . {
	R = C;
}

xx_implements_list(R) ::= xx_implements_list(L) COMMA xx_implements(I) . {
	R = xx_ret_list(L, I);
}

xx_implements_list(R) ::= xx_implements(I) . {
	R = xx_ret_list(NULL, I);
}

xx_implements(R) ::= IDENTIFIER(I) . {
	R = xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state);
}

xx_interface_body(R) ::= BRACKET_OPEN BRACKET_CLOSE . {
  R = NULL;
}

xx_interface_body(R) ::= BRACKET_OPEN xx_interface_definition(D) BRACKET_CLOSE . {
  R = D;
}

xx_class_definition(R) ::= xx_class_properties_definition(C) . {
	R = xx_ret_class_definition(C, NULL, NULL, status->scanner_state);
}

xx_class_definition(R) ::= xx_class_consts_definition(C) . {
	R = xx_ret_class_definition(NULL, NULL, C, status->scanner_state);
}

xx_class_definition(R) ::= xx_class_methods_definition(M) . {
	R = xx_ret_class_definition(NULL, M, NULL, status->scanner_state);
}

xx_class_definition(R) ::= xx_class_properties_definition(C) xx_class_methods_definition(M) . {
	R = xx_ret_class_definition(C, M, NULL, status->scanner_state);
}

xx_class_definition(R) ::= xx_class_properties_definition(C) xx_class_consts_definition(K) . {
	R = xx_ret_class_definition(C, NULL, K, status->scanner_state);
}

xx_class_definition(R) ::= xx_class_consts_definition(K) xx_class_properties_definition(C) . {
	R = xx_ret_class_definition(C, NULL, K, status->scanner_state);
}

xx_class_definition(R) ::= xx_class_consts_definition(K) xx_class_methods_definition(M) . {
	R = xx_ret_class_definition(NULL, M, K, status->scanner_state);
}

xx_class_definition(R) ::= xx_class_properties_definition(C) xx_class_consts_definition(K) xx_class_methods_definition(M) . {
	R = xx_ret_class_definition(C, M, K, status->scanner_state);
}

xx_class_definition(R) ::= xx_class_consts_definition(K) xx_class_properties_definition(C) xx_class_methods_definition(M) . {
	R = xx_ret_class_definition(C, M, K, status->scanner_state);
}

xx_interface_definition(R) ::= xx_class_consts_definition(C) . {
  R = xx_ret_interface_definition(NULL, C, status->scanner_state);
}

xx_interface_definition(R) ::= xx_interface_methods_definition(M) . {
  R = xx_ret_interface_definition(M, NULL, status->scanner_state);
}

xx_interface_definition(R) ::= xx_class_consts_definition(C) xx_interface_methods_definition(M) . {
  R = xx_ret_interface_definition(M, C, status->scanner_state);
}

xx_class_properties_definition(R) ::= xx_class_properties_definition(L) xx_class_property_definition(P) . {
	R = xx_ret_list(L, P);
}

xx_class_properties_definition(R) ::= xx_class_property_definition(P) . {
	R = xx_ret_list(NULL, P);
}

/* property definition */
xx_class_property_definition(R) ::= COMMENT(C) xx_visibility_list(V) IDENTIFIER(I) DOTCOMMA . {
	R = xx_ret_class_property(V, I, NULL, C, NULL, status->scanner_state);
}

xx_class_property_definition(R) ::= xx_visibility_list(V) IDENTIFIER(I) DOTCOMMA . {
	R = xx_ret_class_property(V, I, NULL, NULL, NULL, status->scanner_state);
}

xx_class_property_definition(R) ::= COMMENT(C) xx_visibility_list(V) IDENTIFIER(I) ASSIGN xx_literal_expr(E) DOTCOMMA . {
	R = xx_ret_class_property(V, I, E, C, NULL, status->scanner_state);
}

xx_class_property_definition(R) ::=  xx_visibility_list(V) IDENTIFIER(I) ASSIGN xx_literal_expr(E) DOTCOMMA . {
	R = xx_ret_class_property(V, I, E, NULL, NULL, status->scanner_state);
}

xx_class_property_definition(R) ::= COMMENT(C) xx_visibility_list(V) IDENTIFIER(I) xx_class_property_shortcuts(S) DOTCOMMA . {
	R = xx_ret_class_property(V, I, NULL, C, S, status->scanner_state);
}

xx_class_property_definition(R) ::= xx_visibility_list(V) IDENTIFIER(I) xx_class_property_shortcuts(S) DOTCOMMA . {
	R = xx_ret_class_property(V, I, NULL, NULL, S, status->scanner_state);
}

xx_class_property_definition(R) ::= COMMENT(C) xx_visibility_list(V) IDENTIFIER(I) ASSIGN xx_literal_expr(E) xx_class_property_shortcuts(S) DOTCOMMA . {
	R = xx_ret_class_property(V, I, E, C, S, status->scanner_state);
}

xx_class_property_definition(R) ::=  xx_visibility_list(V) IDENTIFIER(I) ASSIGN xx_literal_expr(E) xx_class_property_shortcuts(S) DOTCOMMA . {
	R = xx_ret_class_property(V, I, E, NULL, S, status->scanner_state);
}

xx_class_property_shortcuts(R) ::= BRACKET_OPEN BRACKET_CLOSE . {
	R = NULL;
}

xx_class_property_shortcuts(R) ::= BRACKET_OPEN xx_class_property_shortcuts_list(L) BRACKET_CLOSE . {
	R = L;
}

xx_class_property_shortcuts_list(R) ::= xx_class_property_shortcuts_list(L) COMMA xx_class_property_shortcut(S) . {
	R = xx_ret_list(L, S);
}

xx_class_property_shortcuts_list(R) ::= xx_class_property_shortcut(S) . {
	R = xx_ret_list(NULL, S);
}

xx_class_property_shortcut(R) ::= IDENTIFIER(D) . {
	R = xx_ret_property_shortcut(NULL, D, status->scanner_state);
}

xx_class_property_shortcut(R) ::= COMMENT(C) IDENTIFIER(D) . {
	R = xx_ret_property_shortcut(C, D, status->scanner_state);
}

/* constants definition */
xx_class_consts_definition(R) ::= xx_class_consts_definition(L) xx_class_const_definition(K) . {
	R = xx_ret_list(L, K);
}

xx_class_consts_definition(R) ::= xx_class_const_definition(K) . {
	R = xx_ret_list(NULL, K);
}

xx_class_methods_definition(R) ::= xx_class_methods_definition(L) xx_class_method_definition(P) . {
	R = xx_ret_list(L, P);
}

xx_class_methods_definition(R) ::= xx_class_method_definition(P) . {
	R = xx_ret_list(NULL, P);
}

xx_interface_methods_definition(R) ::= xx_interface_methods_definition(L) xx_interface_method_definition(P) . {
	R = xx_ret_list(L, P);
}

xx_interface_methods_definition(R) ::= xx_interface_method_definition(P) . {
	R = xx_ret_list(NULL, P);
}

xx_class_const_definition(R) ::= COMMENT(C) CONST CONSTANT(I) ASSIGN xx_literal_expr(E) DOTCOMMA . {
	R = xx_ret_class_const(I, E, C, status->scanner_state);
}

xx_class_const_definition(R) ::= CONST CONSTANT(I) ASSIGN xx_literal_expr(E) DOTCOMMA . {
	R = xx_ret_class_const(I, E, NULL, status->scanner_state);
}

xx_class_const_definition(R) ::= COMMENT(C) CONST IDENTIFIER(I) ASSIGN xx_literal_expr(E) DOTCOMMA . {
	R = xx_ret_class_const(I, E, C, status->scanner_state);
}

xx_class_const_definition(R) ::= CONST IDENTIFIER(I) ASSIGN xx_literal_expr(E) DOTCOMMA . {
	R = xx_ret_class_const(I, E, NULL, status->scanner_state);
}

/** method definition */


/** xx_visibility_list FUNCTION (xx_parameter_list) {} */
xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, NULL, NULL, NULL, NULL, status->scanner_state);
}

/** xx_visibility_list FUNCTION (xx_parameter_list); */
xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE DOTCOMMA . {
	R = xx_ret_class_method(V, I, NULL, NULL, NULL, NULL, status->scanner_state);
}

/** xx_visibility_list FUNCTION (xx_parameter_list) {} */
xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, L, NULL, NULL, NULL, status->scanner_state);
}

/** xx_visibility_list FUNCTION (xx_parameter_list); */
xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE DOTCOMMA . {
	R = xx_ret_class_method(V, I, L, NULL, NULL, NULL, status->scanner_state);
}

/** xx_visibility_list FUNCTION () { xx_statement_list } */
xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, NULL, S, NULL, NULL, status->scanner_state);
}

xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, L, S, NULL, NULL, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, NULL, NULL, C, NULL, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE DOTCOMMA . {
	R = xx_ret_class_method(V, I, NULL, NULL, C, NULL, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, L, NULL, C, NULL, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE DOTCOMMA . {
	R = xx_ret_class_method(V, I, L, NULL, C, NULL, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, NULL, S, C, NULL, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, L, S, C, NULL, status->scanner_state);
}

xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE ARROW xx_method_return_type(T) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, NULL, NULL, NULL, T, status->scanner_state);
}

xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE ARROW xx_method_return_type(T) DOTCOMMA . {
	R = xx_ret_class_method(V, I, NULL, NULL, NULL, T, status->scanner_state);
}

xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE ARROW xx_method_return_type(T) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, L, NULL, NULL, T, status->scanner_state);
}

xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE ARROW xx_method_return_type(T) DOTCOMMA . {
	R = xx_ret_class_method(V, I, L, NULL, NULL, T, status->scanner_state);
}

xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE ARROW xx_method_return_type(T) BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, NULL, S, NULL, T, status->scanner_state);
}

xx_class_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE ARROW xx_method_return_type(T) BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, L, S, NULL, T, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE ARROW xx_method_return_type(T) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, NULL, NULL, C, T, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE ARROW xx_method_return_type(T) DOTCOMMA . {
	R = xx_ret_class_method(V, I, NULL, NULL, C, T, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE ARROW xx_method_return_type(T) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, L, NULL, C, T, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE ARROW xx_method_return_type(T) DOTCOMMA . {
	R = xx_ret_class_method(V, I, L, NULL, C, T, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE ARROW xx_method_return_type(T) BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, NULL, S, C, T, status->scanner_state);
}

xx_class_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE ARROW xx_method_return_type(T) BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_class_method(V, I, L, S, C, T, status->scanner_state);
}

/* method definition */
xx_interface_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE ARROW xx_method_return_type(T) DOTCOMMA . {
	R = xx_ret_class_method(V, I, NULL, NULL, NULL, T, status->scanner_state);
}

xx_interface_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE ARROW xx_method_return_type(T) DOTCOMMA . {
	R = xx_ret_class_method(V, I, L, NULL, NULL, T, status->scanner_state);
}

xx_interface_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE ARROW xx_method_return_type(T) DOTCOMMA . {
	R = xx_ret_class_method(V, I, NULL, NULL, C, T, status->scanner_state);
}

xx_interface_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE ARROW xx_method_return_type(T) DOTCOMMA . {
	R = xx_ret_class_method(V, I, L, NULL, C, T, status->scanner_state);
}

xx_interface_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE DOTCOMMA . {
	R = xx_ret_class_method(V, I, NULL, NULL, NULL, NULL, status->scanner_state);
}

xx_interface_method_definition(R) ::= xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE DOTCOMMA . {
	R = xx_ret_class_method(V, I, L, NULL, NULL, NULL, status->scanner_state);
}

xx_interface_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE DOTCOMMA . {
	R = xx_ret_class_method(V, I, NULL, NULL, C, NULL, status->scanner_state);
}

xx_interface_method_definition(R) ::= COMMENT(C) xx_visibility_list(V) FUNCTION IDENTIFIER(I) PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE DOTCOMMA . {
	R = xx_ret_class_method(V, I, L, NULL, C, NULL, status->scanner_state);
}

/* visibility and modifiers */
xx_visibility_list(R) ::= xx_visibility_list(L) xx_visibility(K) . {
	R = xx_ret_list(L, K);
}

xx_visibility_list(R) ::= xx_visibility(K) . {
	R = xx_ret_list(NULL, K);
}

xx_visibility(R) ::= PUBLIC . {
	R = new Json::Value("public");
}

xx_visibility(R) ::= PROTECTED . {
	R = new Json::Value("protected");
}

xx_visibility(R) ::= PRIVATE. {
	R = new Json::Value("private");
}

xx_visibility(R) ::= STATIC . {
	R = new Json::Value("static");
}

xx_visibility(R) ::= SCOPED . {
	R = new Json::Value("scoped");
}

xx_visibility(R) ::= INLINE . {
	R = new Json::Value("inline");
}

xx_visibility(R) ::= DEPRECATED . {
	R = new Json::Value("deprecated");
}

xx_visibility(R) ::= ABSTRACT . {
	R = new Json::Value("abstract");
}

xx_visibility(R) ::= FINAL . {
	R = new Json::Value("final");
}

/* return type */
xx_method_return_type(R) ::= VOID . {
	R = xx_ret_return_type(1, NULL, status->scanner_state);
}

xx_method_return_type(R) ::= xx_method_return_type_list(L) . {
	R = xx_ret_return_type(0, L, status->scanner_state);
}

xx_method_return_type_list(R) ::= xx_method_return_type_list(L) BITWISE_OR xx_method_return_type_item(I) . {
	R = xx_ret_list(L, I);
}

xx_method_return_type_list(R) ::= xx_method_return_type_item(I) . {
	R = xx_ret_list(NULL, I);
}

xx_method_return_type_item(R) ::= xx_parameter_type(T) . {
	R = xx_ret_return_type_item(T, NULL, 0, 0, status->scanner_state);
}

xx_method_return_type_item(R) ::= NULL . {
	R = xx_ret_return_type_item(xx_ret_type(XX_T_TYPE_NULL), NULL, 0, 0, status->scanner_state);
}

xx_method_return_type_item(R) ::= THIS . {
	R = xx_ret_return_type_item(xx_ret_type(XX_T_TYPE_THIS), NULL, 0, 0, status->scanner_state);
}

xx_method_return_type_item(R) ::= xx_parameter_type(T) NOT . {
	R = xx_ret_return_type_item(T, NULL, 1, 0, status->scanner_state);
}

xx_method_return_type_item(R) ::= xx_parameter_cast(T) . {
	R = xx_ret_return_type_item(NULL, T, 0, 0, status->scanner_state);
}

xx_method_return_type_item(R) ::= xx_parameter_cast_collection(T) . {
	R = xx_ret_return_type_item(NULL, T, 0, 1, status->scanner_state);
}

/* parameters list */
xx_parameter_list(R) ::= xx_parameter_list(L) COMMA xx_parameter(P) . {
	R = xx_ret_list(L, P);
}

xx_parameter_list(R) ::= xx_parameter(P) . {
	R = xx_ret_list(NULL, P);
}

/* xx_parameter_list */
xx_parameter(R) ::= IDENTIFIER(I) . {
	R = xx_ret_parameter(0, NULL, NULL, I, NULL, 0, status->scanner_state);
}

xx_parameter(R) ::= CONST IDENTIFIER(I) . {
	R = xx_ret_parameter(1, NULL, NULL, I, NULL, 0, status->scanner_state);
}

xx_parameter(R) ::= xx_parameter_type(T) IDENTIFIER(I) . {
	R = xx_ret_parameter(0, T, NULL, I, NULL, 0, status->scanner_state);
}

xx_parameter(R) ::= CONST xx_parameter_type(T) IDENTIFIER(I) . {
	R = xx_ret_parameter(1, T, NULL, I, NULL, 0, status->scanner_state);
}

xx_parameter(R) ::= xx_parameter_type(T) NOT IDENTIFIER(I) . {
	R = xx_ret_parameter(0, T, NULL, I, NULL, 1, status->scanner_state);
}

xx_parameter(R) ::= CONST xx_parameter_type(T) NOT IDENTIFIER(I) . {
	R = xx_ret_parameter(1, T, NULL, I, NULL, 1, status->scanner_state);
}

xx_parameter(R) ::= xx_parameter_cast(C) IDENTIFIER(I) . {
	R = xx_ret_parameter(0, NULL, C, I, NULL, 0, status->scanner_state);
}

xx_parameter(R) ::= CONST xx_parameter_cast(C) IDENTIFIER(I) . {
	R = xx_ret_parameter(1, NULL, C, I, NULL, 0, status->scanner_state);
}

xx_parameter(R) ::= IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_parameter(0, NULL, NULL, I, E, 0, status->scanner_state);
}

xx_parameter(R) ::= CONST IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_parameter(1, NULL, NULL, I, E, 0, status->scanner_state);
}

xx_parameter(R) ::= xx_parameter_type(T) IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_parameter(0, T, NULL, I, E, 0, status->scanner_state);
}

xx_parameter(R) ::= CONST xx_parameter_type(T) IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_parameter(1, T, NULL, I, E, 0, status->scanner_state);
}

xx_parameter(R) ::= xx_parameter_type(T) NOT IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_parameter(0, T, NULL, I, E, 1, status->scanner_state);
}

xx_parameter(R) ::= CONST xx_parameter_type(T) NOT IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_parameter(1, T, NULL, I, E, 1, status->scanner_state);
}

xx_parameter(R) ::= xx_parameter_cast(C) IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_parameter(0, NULL, C, I, E, 0, status->scanner_state);
}

xx_parameter(R) ::= CONST xx_parameter_cast(C) IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_parameter(1, NULL, C, I, E, 0, status->scanner_state);
}

/* xx_parameter_cast */
xx_parameter_cast(R) ::= LESS IDENTIFIER(I) GREATER . {
	R = xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state);
}

xx_parameter_cast_collection(R) ::= LESS IDENTIFIER(I) SBRACKET_OPEN SBRACKET_CLOSE GREATER . {
	R = xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state);
}

xx_parameter_type(R) ::= TYPE_INTEGER . {
	R = xx_ret_type(XX_TYPE_INTEGER);
}

xx_parameter_type(R) ::= TYPE_UINTEGER . {
	R = xx_ret_type(XX_TYPE_UINTEGER);
}

xx_parameter_type(R) ::= TYPE_LONG . {
	R = xx_ret_type(XX_TYPE_LONG);
}

xx_parameter_type(R) ::= TYPE_ULONG . {
	R = xx_ret_type(XX_TYPE_ULONG);
}

xx_parameter_type(R) ::= TYPE_CHAR . {
	R = xx_ret_type(XX_TYPE_CHAR);
}

xx_parameter_type(R) ::= TYPE_UCHAR . {
	R = xx_ret_type(XX_TYPE_UCHAR);
}

xx_parameter_type(R) ::= TYPE_DOUBLE . {
	R = xx_ret_type(XX_TYPE_DOUBLE);
}

xx_parameter_type(R) ::= TYPE_BOOL . {
	R = xx_ret_type(XX_TYPE_BOOL);
}

xx_parameter_type(R) ::= TYPE_STRING . {
	R = xx_ret_type(XX_TYPE_STRING);
}

xx_parameter_type(R) ::= TYPE_ARRAY . {
	R = xx_ret_type(XX_TYPE_ARRAY);
}

xx_parameter_type(R) ::= TYPE_VAR . {
	R = xx_ret_type(XX_TYPE_VAR);
}

xx_parameter_type(R) ::= TYPE_CALLABLE . {
	R = xx_ret_type(XX_TYPE_CALLABLE);
}

xx_parameter_type(R) ::= TYPE_RESOURCE . {
	R = xx_ret_type(XX_TYPE_RESOURCE);
}

xx_parameter_type(R) ::= TYPE_OBJECT . {
	R = xx_ret_type(XX_TYPE_OBJECT);
}

xx_statement_list(R) ::= xx_statement_list(L) xx_statement(S) . {
	R = xx_ret_list(L, S);
}

xx_statement_list(R) ::= xx_statement(S) . {
	R = xx_ret_list(NULL, S);
}

xx_statement(R) ::= xx_cblock(S) . {
	R = S;
}

xx_statement(R) ::= xx_let_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_if_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_loop_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_echo_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_return_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_require_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_fetch_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_fcall_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_mcall_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_scall_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_unset_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_throw_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_declare_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_break_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_continue_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_while_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_do_while_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_try_catch_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_switch_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_for_statement(S) . {
	R = S;
}

xx_statement(R) ::= xx_comment(S) . {
	R = S;
}

xx_statement(R) ::= xx_empty_statement(S) . {
	R = S;
}

xx_empty_statement(R) ::= DOTCOMMA . {
	R = xx_ret_empty_statement(status->scanner_state);
}

xx_break_statement(R) ::= BREAK DOTCOMMA . {
	R = xx_ret_break_statement(status->scanner_state);
}

xx_continue_statement(R) ::= CONTINUE DOTCOMMA . {
	R = xx_ret_continue_statement(status->scanner_state);
}

/* if(a) {} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, NULL, NULL, NULL, status->scanner_state);
}

/* if(a) {} elseif(b) {} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN BRACKET_CLOSE xx_elseif_statements(L) . {
	R = xx_ret_if_statement(E, NULL, NULL, L, status->scanner_state);
}

/* if(a) {} else {} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN BRACKET_CLOSE ELSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, NULL, NULL, NULL, status->scanner_state);
}

/* if(a) {} elseif(b) {} else {} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN BRACKET_CLOSE xx_elseif_statements(L) ELSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, NULL, L, NULL, status->scanner_state);
}

/* if(a) {...} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, L, NULL, NULL, status->scanner_state);
}

/* if(a) {...} elseif(b) {...} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE xx_elseif_statements(S) . {
	R = xx_ret_if_statement(E, L, S, NULL, status->scanner_state);
}

/* if(a) {...} else {...} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE ELSE BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, L, NULL, S, status->scanner_state);
}

/* if(a) {...} elseif(b) {...} else {...} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE xx_elseif_statements(ES) ELSE BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, L, ES, S, status->scanner_state);
}

/* if(a) {...} else {} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE ELSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, L, NULL, NULL, status->scanner_state);
}

/* if(a) {...} elseif(b) {} else {} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE xx_elseif_statements(S) ELSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, L, S, NULL, status->scanner_state);
}

/* if(a) {} else {...} */
xx_if_statement(R) ::= IF xx_eval_expr(E) BRACKET_OPEN BRACKET_CLOSE ELSE BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, NULL, NULL, L, status->scanner_state);
}

xx_elseif_statements(R) ::= xx_elseif_statements(C) xx_elseif_statement(K) . {
	R = xx_ret_list(C, K);
}

xx_elseif_statements(R) ::= xx_elseif_statement(K) . {
	R = xx_ret_list(NULL, K);
}

/* elseif(b) {} */
xx_elseif_statement(R) ::= ELSEIF xx_eval_expr(E) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, NULL, NULL, NULL, status->scanner_state);
}

/* elseif(b) {...} */
xx_elseif_statement(R) ::= ELSEIF xx_eval_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_if_statement(E, L, NULL, NULL, status->scanner_state);
}

xx_switch_statement(R) ::= SWITCH xx_eval_expr(E) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_switch_statement(E, NULL, status->scanner_state);
}

xx_switch_statement(R) ::= SWITCH xx_eval_expr(E) BRACKET_OPEN xx_case_clauses(C) BRACKET_CLOSE . {
	R = xx_ret_switch_statement(E, C, status->scanner_state);
}

xx_case_clauses(R) ::= xx_case_clauses(C) xx_case_clause(K) . {
	R = xx_ret_list(C, K);
}

xx_case_clauses(R) ::= xx_case_clause(K) . {
	R = xx_ret_list(NULL, K);
}

xx_case_clause(R) ::= CASE xx_literal_expr(E) COLON . {
	R = xx_ret_case_clause(E, NULL, status->scanner_state);
}

xx_case_clause(R) ::= CASE xx_literal_expr(E) COLON xx_statement_list(L) . {
	R = xx_ret_case_clause(E, L, status->scanner_state);
}

xx_case_clause(R) ::= DEFAULT COLON xx_statement_list(L) . {
	R = xx_ret_case_clause(NULL, L, status->scanner_state);
}

xx_loop_statement(R) ::= LOOP BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_loop_statement(NULL, status->scanner_state);
}

xx_loop_statement(R) ::= LOOP BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_loop_statement(L, status->scanner_state);
}

xx_while_statement(R) ::= WHILE xx_eval_expr(E) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_while_statement(E, NULL, status->scanner_state);
}

xx_while_statement(R) ::= WHILE xx_eval_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_while_statement(E, L, status->scanner_state);
}

xx_do_while_statement(R) ::= DO BRACKET_OPEN BRACKET_CLOSE WHILE xx_eval_expr(E) DOTCOMMA . {
	R = xx_ret_do_while_statement(E, NULL, status->scanner_state);
}

xx_do_while_statement(R) ::= DO BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE WHILE xx_eval_expr(E) DOTCOMMA . {
	R = xx_ret_do_while_statement(E, L, status->scanner_state);
}

xx_try_catch_statement(R) ::= TRY BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_try_catch_statement(NULL, NULL, status->scanner_state);
}

xx_try_catch_statement(R) ::= TRY BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_try_catch_statement(L, NULL, status->scanner_state);
}

xx_try_catch_statement(R) ::= TRY BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE xx_catch_statement_list(C) . {
	R = xx_ret_try_catch_statement(L, C, status->scanner_state);
}

xx_catch_statement_list(R) ::= xx_catch_statement_list(L) xx_catch_statement(C) . {
	R = xx_ret_list(L, C);
}

xx_catch_statement_list(R) ::= xx_catch_statement(C) . {
	R = xx_ret_list(NULL, C);
}

xx_catch_statement(R) ::= CATCH xx_catch_classes_list(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_catch_statement(E, NULL, L, status->scanner_state);
}

xx_catch_statement(R) ::= CATCH xx_catch_classes_list(E) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_catch_statement(E, NULL, NULL, status->scanner_state);
}

xx_catch_statement(R) ::= CATCH xx_catch_classes_list(E) COMMA IDENTIFIER(V) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_catch_statement(E, xx_ret_literal(XX_T_IDENTIFIER, V, status->scanner_state), NULL, status->scanner_state);
}

xx_catch_statement(R) ::= CATCH xx_catch_classes_list(E) COMMA IDENTIFIER(V) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_catch_statement(E, xx_ret_literal(XX_T_IDENTIFIER, V, status->scanner_state), L, status->scanner_state);
}

xx_catch_classes_list(R) ::= xx_catch_classes_list(L) BITWISE_OR xx_catch_class(C) . {
	R = xx_ret_list(L, C);
}

xx_catch_classes_list(R) ::= xx_catch_class(C) . {
	R = xx_ret_list(NULL, C);
}

xx_catch_class(R) ::= IDENTIFIER(C) . {
	R = xx_ret_literal(XX_T_IDENTIFIER, C, status->scanner_state);
}

xx_for_statement(R) ::= FOR IDENTIFIER(V) IN xx_common_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_for_statement(E, NULL, V, 0, L, status->scanner_state);
}

xx_for_statement(R) ::= FOR IDENTIFIER(V) IN xx_common_expr(E) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_for_statement(E, NULL, V, 0, NULL, status->scanner_state);
}

xx_for_statement(R) ::= FOR IDENTIFIER(V) IN REVERSE xx_common_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_for_statement(E, NULL, V, 1, L, status->scanner_state);
}

xx_for_statement(R) ::= FOR IDENTIFIER(K) COMMA IDENTIFIER(V) IN xx_common_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_for_statement(E, K, V, 0, L, status->scanner_state);
}

xx_for_statement(R) ::= FOR IDENTIFIER(K) COMMA IDENTIFIER(V) IN xx_common_expr(E) BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_for_statement(E, K, V, 0, NULL, status->scanner_state);
}

xx_for_statement(R) ::= FOR IDENTIFIER(K) COMMA IDENTIFIER(V) IN REVERSE xx_common_expr(E) BRACKET_OPEN xx_statement_list(L) BRACKET_CLOSE . {
	R = xx_ret_for_statement(E, K, V, 1, L, status->scanner_state);
}

xx_let_statement(R) ::= LET xx_let_assignments(A) DOTCOMMA . {
	R = xx_ret_let_statement(A, status->scanner_state);
}

xx_let_assignments(R) ::= xx_let_assignments(L) COMMA xx_let_assignment(A) . {
	R = xx_ret_list(L, A);
}

xx_let_assignments(R) ::= xx_let_assignment(A) . {
	R = xx_ret_list(NULL, A);
}

/* */
xx_assignment_operator(R) ::= ASSIGN . {
	R = new Json::Value("assign");
}

/* */
xx_assignment_operator(R) ::= ADDASSIGN . {
	R = new Json::Value("add-assign");
}

/* */
xx_assignment_operator(R) ::= SUBASSIGN . {
	R = new Json::Value("sub-assign");
}

xx_assignment_operator(R) ::= MULASSIGN . {
	R = new Json::Value("mul-assign");
}

xx_assignment_operator(R) ::= DIVASSIGN . {
	R = new Json::Value("div-assign");
}

xx_assignment_operator(R) ::= CONCATASSIGN . {
	R = new Json::Value("concat-assign");
}

xx_assignment_operator(R) ::= MODASSIGN . {
	R = new Json::Value("mod-assign");
}

/* y = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(I) xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("variable", O, I, NULL, NULL, E, status->scanner_state);
}

/* y->x = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) ARROW IDENTIFIER(I) xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("object-property", O, D, I, NULL, E, status->scanner_state);
}

/* y->{x} = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) ARROW BRACKET_OPEN IDENTIFIER(I) BRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("variable-dynamic-object-property", O, D, I, NULL, E, status->scanner_state);
}

/* y->{"x"} = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) ARROW BRACKET_OPEN STRING(S) BRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("string-dynamic-object-property", O, D, S, NULL, E, status->scanner_state);
}

/* y->x[] = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) ARROW IDENTIFIER(I) SBRACKET_OPEN SBRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("object-property-append", O, D, I, NULL, E, status->scanner_state);
}

/* y->x[z][] = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) ARROW IDENTIFIER(I) xx_array_offset_list(X) xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("object-property-array-index", O, D, I, X, E, status->scanner_state);
}

xx_let_assignment(R) ::= IDENTIFIER(D) ARROW IDENTIFIER(I) xx_array_offset_list(X) SBRACKET_OPEN SBRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("object-property-array-index-append", O, D, I, X, E, status->scanner_state);
}

/* y::x = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) DOUBLECOLON IDENTIFIER(I) xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("static-property", O, D, I, NULL, E, status->scanner_state);
}

/* y::x[] = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) DOUBLECOLON IDENTIFIER(I) SBRACKET_OPEN SBRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("static-property-append", O, D, I, NULL, E, status->scanner_state);
}

/* y::x[z] = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) DOUBLECOLON IDENTIFIER(I) xx_array_offset_list(X) xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("static-property-array-index", O, D, I, X, E, status->scanner_state);
}

/* y::x[z][] = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) DOUBLECOLON IDENTIFIER(I) xx_array_offset_list(X) SBRACKET_OPEN SBRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("static-property-array-index-append", O, D, I, X, E, status->scanner_state);
}

/* y[] = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(I) SBRACKET_OPEN SBRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("variable-append", O, I, NULL, NULL, E, status->scanner_state);
}

/* y[x] = {expr} | y[x][z] = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) xx_array_offset_list(A) xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("array-index", O, D, NULL, A, E, status->scanner_state);
}

/* y[x][] = {expr} | y[x][z][] = {expr} */
xx_let_assignment(R) ::= IDENTIFIER(D) xx_array_offset_list(A) SBRACKET_OPEN SBRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("array-index-append", O, D, NULL, A, E, status->scanner_state);
}

xx_array_offset_list(R) ::= xx_array_offset_list(L) xx_array_offset(O) . {
	R = xx_ret_list(L, O);
}

xx_array_offset_list(R) ::= xx_array_offset(O) . {
	R = xx_ret_list(NULL, O);
}

xx_array_offset(R) ::= SBRACKET_OPEN xx_index_expr(I) SBRACKET_CLOSE . {
	R = I;
}

/* t->y++ */
xx_let_assignment(R) ::= IDENTIFIER(D) ARROW IDENTIFIER(I) INCR . {
	R = xx_ret_let_assignment("object-property-incr", NULL, D, I, NULL, NULL, status->scanner_state);
}

/* t->y-- */
xx_let_assignment(R) ::= IDENTIFIER(D) ARROW IDENTIFIER(I) DECR . {
	R = xx_ret_let_assignment("object-property-decr", NULL, D, I, NULL, NULL, status->scanner_state);
}

/* y++ */
xx_let_assignment(R) ::= IDENTIFIER(I) INCR . {
	R = xx_ret_let_assignment("incr", NULL, I, NULL, NULL, NULL, status->scanner_state);
}

/* y-- */
xx_let_assignment(R) ::= IDENTIFIER(I) DECR . {
	R = xx_ret_let_assignment("decr", NULL, I, NULL, NULL, NULL, status->scanner_state);
}

/* {y} = {expr} */
xx_let_assignment(R) ::= BRACKET_OPEN IDENTIFIER(I) BRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("dynamic-variable", O, I, NULL, NULL, E, status->scanner_state);
}

/* {"y"} = {expr} */
xx_let_assignment(R) ::= BRACKET_OPEN STRING(S) BRACKET_CLOSE xx_assignment_operator(O) xx_assign_expr(E) . {
	R = xx_ret_let_assignment("dynamic-variable-string", O, S, NULL, NULL, E, status->scanner_state);
}

xx_index_expr(R) ::= xx_common_expr(E) . {
	R = E;
}

xx_echo_statement(R) ::= ECHO xx_echo_expressions(E) DOTCOMMA . {
	R = xx_ret_echo_statement(E, status->scanner_state);
}

xx_echo_expressions(R) ::= xx_echo_expressions(L) COMMA xx_echo_expression(A) . {
	R = xx_ret_list(L, A);
}

xx_echo_expressions(R) ::= xx_echo_expression(A) . {
	R = xx_ret_list(NULL, A);
}

xx_echo_expression(R) ::= xx_common_expr(E) . {
	R = E;
}

/* mcall statement */
xx_mcall_statement(R) ::= xx_mcall_expr(E) DOTCOMMA . {
	R = xx_ret_mcall_statement(E, status->scanner_state);
}

/* fcall statement */
xx_fcall_statement(R) ::= xx_fcall_expr(E) DOTCOMMA . {
	R = xx_ret_fcall_statement(E, status->scanner_state);
}

/* scall statement */
xx_scall_statement(R) ::= xx_scall_expr(E) DOTCOMMA . {
	R = xx_ret_scall_statement(E, status->scanner_state);
}

/* fetch statement */
xx_fetch_statement(R) ::= xx_fetch_expr(E) DOTCOMMA . {
	R = xx_ret_fetch_statement(E, status->scanner_state);
}

/* return statement */
xx_return_statement(R) ::= RETURN xx_common_expr(E) DOTCOMMA . {
	R = xx_ret_return_statement(E, status->scanner_state);
}

/* return statement */
xx_return_statement(R) ::= RETURN DOTCOMMA . {
	R = xx_ret_return_statement(NULL, status->scanner_state);
}

/* require statement */
xx_require_statement(R) ::= REQUIRE xx_common_expr(E) DOTCOMMA . {
	R = xx_ret_require_statement(E, status->scanner_state);
}

/* unset {expr} */
xx_unset_statement(R) ::= UNSET xx_common_expr(E) DOTCOMMA . {
	R = xx_ret_unset_statement(E, status->scanner_state);
}

/* throw {expr} */
xx_throw_statement(R) ::= THROW xx_common_expr(E) DOTCOMMA . {
	R = xx_ret_throw_exception(E, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_INTEGER xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_INTEGER, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_UINTEGER xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_UINTEGER, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_CHAR xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_CHAR, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_UCHAR xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_UCHAR, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_LONG xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_LONG, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_ULONG xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_ULONG, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_DOUBLE xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_DOUBLE, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_STRING xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_STRING, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_BOOL xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_BOOL, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_VAR xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_VAR, L, status->scanner_state);
}

xx_declare_statement(R) ::= TYPE_ARRAY xx_declare_variable_list(L) DOTCOMMA . {
	R = xx_ret_declare_statement(XX_T_TYPE_ARRAY, L, status->scanner_state);
}

xx_declare_variable_list(R) ::= xx_declare_variable_list(L) COMMA xx_declare_variable(V) . {
	R = xx_ret_list(L, V);
}

xx_declare_variable_list(R) ::= xx_declare_variable(V) . {
	R = xx_ret_list(NULL, V);
}

xx_declare_variable(R) ::= IDENTIFIER(I) . {
	R = xx_ret_declare_variable(I, NULL, status->scanner_state);
}

xx_declare_variable(R) ::= IDENTIFIER(I) ASSIGN xx_literal_expr(E) . {
	R = xx_ret_declare_variable(I, E, status->scanner_state);
}

xx_assign_expr(R) ::= xx_common_expr(E) . {
	R = E;
}

xx_common_expr(R) ::= NOT xx_common_expr(O1) . {
	R = xx_ret_expr("not", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= SUB xx_common_expr(O1) . {
	R = xx_ret_expr("minus", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= ISSET xx_common_expr(O1) . {
	R = xx_ret_expr("isset", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= REQUIRE xx_common_expr(O1) . {
	R = xx_ret_expr("require", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= CLONE xx_common_expr(O1) . {
	R = xx_ret_expr("clone", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= EMPTY xx_common_expr(O1) . {
	R = xx_ret_expr("empty", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= LIKELY xx_common_expr(O1) . {
	R = xx_ret_expr("likely", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= UNLIKELY xx_common_expr(O1) . {
	R = xx_ret_expr("unlikely", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(O1) EQUALS xx_common_expr(O2) . {
	R = xx_ret_expr("equals", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(O1) NOTEQUALS xx_common_expr(O2) . {
	R = xx_ret_expr("not-equals", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(O1) IDENTICAL xx_common_expr(O2) . {
	R = xx_ret_expr("identical", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(O1) NOTIDENTICAL xx_common_expr(O2) . {
	R = xx_ret_expr("not-identical", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(O1) LESS xx_common_expr(O2) . {
	R = xx_ret_expr("less", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(O1) GREATER xx_common_expr(O2) . {
	R = xx_ret_expr("greater", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(O1) LESSEQUAL xx_common_expr(O2) . {
	R = xx_ret_expr("less-equal", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(O1) GREATEREQUAL xx_common_expr(O2) . {
	R = xx_ret_expr("greater-equal", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= PARENTHESES_OPEN xx_common_expr(O1) PARENTHESES_CLOSE . {
	R = xx_ret_expr("list", O1, NULL, NULL, status->scanner_state);
}

xx_common_expr(R) ::= PARENTHESES_OPEN xx_parameter_type(O1) PARENTHESES_CLOSE xx_common_expr(O2) . {
	R = xx_ret_expr("cast", O1, O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= LESS IDENTIFIER(I) GREATER xx_common_expr(O2) . {
	R = xx_ret_expr("type-hint", xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state), O2, NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(V) ARROW IDENTIFIER(I) . {
	R = xx_ret_expr("property-access", V, xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state), NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(V) ARROW BRACKET_OPEN IDENTIFIER(I) BRACKET_CLOSE . {
	R = xx_ret_expr("property-dynamic-access", V, xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state), NULL, status->scanner_state);
}

xx_common_expr(R) ::= xx_common_expr(V) ARROW BRACKET_OPEN STRING(S) BRACKET_CLOSE . {
	R = xx_ret_expr("property-string-access", V, xx_ret_literal(XX_T_STRING, S, status->scanner_state), NULL, status->scanner_state);
}

xx_common_expr(R) ::= IDENTIFIER(V) DOUBLECOLON IDENTIFIER(I) . {
	R = xx_ret_expr("static-property-access", xx_ret_literal(XX_T_IDENTIFIER, V, status->scanner_state), xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state), NULL, status->scanner_state);
}

xx_common_expr(R) ::= IDENTIFIER(V) DOUBLECOLON CONSTANT(I) . {
	R = xx_ret_expr("static-constant-access", xx_ret_literal(XX_T_IDENTIFIER, V, status->scanner_state), xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state), NULL, status->scanner_state);
}

/* y = v[expr] */
/*xx_common_expr(R) ::= IDENTIFIER(V) SBRACKET_OPEN xx_common_expr(I) SBRACKET_CLOSE . {
	R = xx_ret_expr("array-access", xx_ret_literal(XX_T_IDENTIFIER, V, status->scanner_state), I, NULL, status->scanner_state);
}*/

xx_common_expr(R) ::= xx_common_expr(V) SBRACKET_OPEN xx_common_expr(I) SBRACKET_CLOSE . {
	R = xx_ret_expr("array-access", V, I, NULL, status->scanner_state);
}

/* y = a + b */
xx_common_expr(R) ::= xx_common_expr(O1) ADD xx_common_expr(O2) . {
	R = xx_ret_expr("add", O1, O2, NULL, status->scanner_state);
}

/* y = a - b */
xx_common_expr(R) ::= xx_common_expr(O1) SUB xx_common_expr(O2) . {
	R = xx_ret_expr("sub", O1, O2, NULL, status->scanner_state);
}

/* y = a * b */
xx_common_expr(R) ::= xx_common_expr(O1) MUL xx_common_expr(O2) . {
	R = xx_ret_expr("mul", O1, O2, NULL, status->scanner_state);
}

/* y = a / b */
xx_common_expr(R) ::= xx_common_expr(O1) DIV xx_common_expr(O2) . {
	R = xx_ret_expr("div", O1, O2, NULL, status->scanner_state);
}

/* y = a % b */
xx_common_expr(R) ::= xx_common_expr(O1) MOD xx_common_expr(O2) . {
	R = xx_ret_expr("mod", O1, O2, NULL, status->scanner_state);
}

/* y = a . b */
xx_common_expr(R) ::= xx_common_expr(O1) CONCAT xx_common_expr(O2) . {
	R = xx_ret_expr("concat", O1, O2, NULL, status->scanner_state);
}

/* y = a && b */
xx_common_expr(R) ::= xx_common_expr(O1) AND xx_common_expr(O2) . {
	R = xx_ret_expr("and", O1, O2, NULL, status->scanner_state);
}

/* y = a || b */
xx_common_expr(R) ::= xx_common_expr(O1) OR xx_common_expr(O2) . {
	R = xx_ret_expr("or", O1, O2, NULL, status->scanner_state);
}

/* y = a & b */
xx_common_expr(R) ::= xx_common_expr(O1) BITWISE_AND xx_common_expr(O2) . {
	R = xx_ret_expr("bitwise_and", O1, O2, NULL, status->scanner_state);
}

/* y = a | b */
xx_common_expr(R) ::= xx_common_expr(O1) BITWISE_OR xx_common_expr(O2) . {
	R = xx_ret_expr("bitwise_or", O1, O2, NULL, status->scanner_state);
}

/* y = a ^ b */
xx_common_expr(R) ::= xx_common_expr(O1) BITWISE_XOR xx_common_expr(O2) . {
	R = xx_ret_expr("bitwise_xor", O1, O2, NULL, status->scanner_state);
}

/* y = a << b */
xx_common_expr(R) ::= xx_common_expr(O1) BITWISE_SHIFTLEFT xx_common_expr(O2) . {
	R = xx_ret_expr("bitwise_shiftleft", O1, O2, NULL, status->scanner_state);
}

/* y = a >> b */
xx_common_expr(R) ::= xx_common_expr(O1) BITWISE_SHIFTRIGHT xx_common_expr(O2) . {
	R = xx_ret_expr("bitwise_shiftright", O1, O2, NULL, status->scanner_state);
}

/* y = a instanceof b */
xx_common_expr(R) ::= xx_common_expr(O1) INSTANCEOF xx_common_expr(O2) . {
	R = xx_ret_expr("instanceof", O1, O2, NULL, status->scanner_state);
}

/* y = fetch x, z[k] */
xx_fetch_expr(R) ::= FETCH IDENTIFIER(O1) COMMA xx_common_expr(O2) . {
	R = xx_ret_expr("fetch", xx_ret_literal(XX_T_IDENTIFIER, O1, status->scanner_state), O2, NULL, status->scanner_state);
}

/* y = fetch x, z[k] */
xx_common_expr(R) ::= xx_fetch_expr(E) . {
	R = E;
}

/* y = typeof b */
xx_common_expr(R) ::= TYPEOF xx_common_expr(O1) . {
	R = xx_ret_expr("typeof", O1, NULL, NULL, status->scanner_state);
}

/* y = x */
xx_common_expr(R) ::= IDENTIFIER(I) . {
	R = xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state);
}

/* y = 100 */
xx_common_expr(R) ::= INTEGER(I) . {
	R = xx_ret_literal(XX_T_INTEGER, I, status->scanner_state);
}

/* y = "hello" */
xx_common_expr(R) ::= STRING(S) . {
	R = xx_ret_literal(XX_T_STRING, S, status->scanner_state);
}

/* y = 'h' */
xx_common_expr(R) ::= CHAR(S) . {
	R = xx_ret_literal(XX_T_CHAR, S, status->scanner_state);
}

/* y = 12.5 */
xx_common_expr(R) ::= DOUBLE(D) . {
	R = xx_ret_literal(XX_T_DOUBLE, D, status->scanner_state);
}

/* y = null */
xx_common_expr(R) ::= NULL . {
	R = xx_ret_literal(XX_T_NULL, NULL, status->scanner_state);
}

/* y = false */
xx_common_expr(R) ::= TRUE . {
	R = xx_ret_literal(XX_T_TRUE, NULL, status->scanner_state);
}

/* y = false */
xx_common_expr(R) ::= FALSE . {
	R = xx_ret_literal(XX_T_FALSE, NULL, status->scanner_state);
}

/* y = XX */
xx_common_expr(R) ::= CONSTANT(I) . {
	R = xx_ret_literal(XX_T_CONSTANT, I, status->scanner_state);
}

/* y = [] */
xx_common_expr(R) ::= SBRACKET_OPEN SBRACKET_CLOSE . {
	R = xx_ret_expr("empty-array", NULL, NULL, NULL, status->scanner_state);
}

/* y = [1, 2, 3] */
xx_common_expr(R) ::= SBRACKET_OPEN xx_array_list(L) SBRACKET_CLOSE . {
	R = xx_ret_expr("array", L, NULL, NULL, status->scanner_state);
}

/* y = new MyClass */
xx_common_expr(R) ::= NEW IDENTIFIER(I) . {
	R = xx_ret_new_instance(0, I, NULL, status->scanner_state);
}

/* y = new MyClass() */
xx_common_expr(R) ::= NEW IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_new_instance(0, I, NULL, status->scanner_state);
}

/* y = new MyClass(false, x) */
xx_common_expr(R) ::= NEW IDENTIFIER(I) PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_new_instance(0, I, P, status->scanner_state);
}

/* y = new {MyClass} */
xx_common_expr(R) ::= NEW BRACKET_OPEN IDENTIFIER(I) BRACKET_CLOSE . {
	R = xx_ret_new_instance(1, I, NULL, status->scanner_state);
}

/* y = new {MyClass}() */
xx_common_expr(R) ::= NEW BRACKET_OPEN IDENTIFIER(I) BRACKET_CLOSE PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_new_instance(1, I, NULL, status->scanner_state);
}

/* y = new {MyClass}(false, x) */
xx_common_expr(R) ::= NEW BRACKET_OPEN IDENTIFIER(I) BRACKET_CLOSE PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_new_instance(1, I, P, status->scanner_state);
}

/* y = f(false, x) */
xx_fcall_expr(R) ::= IDENTIFIER(I) PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_fcall(1, I, P, status->scanner_state);
}

/* y = f() */
xx_fcall_expr(R) ::= IDENTIFIER(I) PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_fcall(1, I, NULL, status->scanner_state);
}

/* y = {f}(false, x) */
xx_fcall_expr(R) ::= BRACKET_OPEN IDENTIFIER(I) BRACKET_CLOSE PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_fcall(2, I, P, status->scanner_state);
}

/* y = {f}() */
xx_fcall_expr(R) ::= BRACKET_OPEN IDENTIFIER(I) BRACKET_CLOSE PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_fcall(2, I, NULL, status->scanner_state);
}

/* o::m(false, x) */
xx_scall_expr(R) ::= IDENTIFIER(O) DOUBLECOLON IDENTIFIER(M) PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_scall(0, O, 0, M, P, status->scanner_state);
}

/* o::m() */
xx_scall_expr(R) ::= IDENTIFIER(O) DOUBLECOLON IDENTIFIER(M) PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_scall(0, O, 0, M, NULL, status->scanner_state);
}

/* {o}::m(false, x) */
xx_scall_expr(R) ::= BRACKET_OPEN IDENTIFIER(O) BRACKET_CLOSE DOUBLECOLON IDENTIFIER(M) PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_scall(1, O, 0, M, P, status->scanner_state);
}

/* {o}::m() */
xx_scall_expr(R) ::= BRACKET_OPEN IDENTIFIER(O) BRACKET_CLOSE DOUBLECOLON IDENTIFIER(M) PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_scall(1, O, 0, M, NULL, status->scanner_state);
}

/* {o}::{m}(false, x) */
xx_scall_expr(R) ::= BRACKET_OPEN IDENTIFIER(O) BRACKET_CLOSE DOUBLECOLON BRACKET_OPEN IDENTIFIER(M) BRACKET_CLOSE PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_scall(1, O, 1, M, P, status->scanner_state);
}

/* {o}::{m}() */
xx_scall_expr(R) ::= BRACKET_OPEN IDENTIFIER(O) BRACKET_CLOSE DOUBLECOLON BRACKET_OPEN IDENTIFIER(M) BRACKET_CLOSE PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_scall(1, O, 1, M, NULL, status->scanner_state);
}

/* o->m(false, x) */
xx_mcall_expr(R) ::= xx_common_expr(O) ARROW IDENTIFIER(M) PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_mcall(1, O, M, P, status->scanner_state);
}

/* o->m() */
xx_mcall_expr(R) ::= xx_common_expr(O) ARROW IDENTIFIER(M) PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_mcall(1, O, M, NULL, status->scanner_state);
}

/* o->{m}(false, x) */
xx_mcall_expr(R) ::= xx_common_expr(O) ARROW BRACKET_OPEN IDENTIFIER(M) BRACKET_CLOSE PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_mcall(2, O, M, P, status->scanner_state);
}

/* o->{m}() */
xx_mcall_expr(R) ::= xx_common_expr(O) ARROW BRACKET_OPEN IDENTIFIER(M) BRACKET_CLOSE PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_mcall(2, O, M, NULL, status->scanner_state);
}

/* o->{"m"}(false, x) */
xx_mcall_expr(R) ::= xx_common_expr(O) ARROW BRACKET_OPEN STRING(S) BRACKET_CLOSE PARENTHESES_OPEN xx_call_parameters(P) PARENTHESES_CLOSE . {
	R = xx_ret_mcall(3, O, S, P, status->scanner_state);
}

/* o->{"m"}() */
xx_mcall_expr(R) ::= xx_common_expr(O) ARROW BRACKET_OPEN STRING(S) BRACKET_CLOSE PARENTHESES_OPEN PARENTHESES_CLOSE . {
	R = xx_ret_mcall(3, O, S, NULL, status->scanner_state);
}

/* y = o->m(false, x) or y = o->m() */
xx_common_expr(R) ::= xx_mcall_expr(E) . {
	R = E;
}

/* y = o::m(false, x) or y = o::m() */
xx_common_expr(R) ::= xx_scall_expr(E) . {
	R = E;
}

/* f() or f(1, 2, 3) */
xx_common_expr(R) ::= xx_fcall_expr(E) . {
	R = E;
}

/* a ? b : c */
xx_common_expr(R) ::= xx_common_expr(O1) QUESTION xx_common_expr(O2) COLON xx_common_expr(O3) . {
	R = xx_ret_expr("ternary", O1, O2, O3, status->scanner_state);
}

xx_call_parameters(R) ::= xx_call_parameters(L) COMMA xx_call_parameter(P) . {
	R = xx_ret_list(L, P);
}

xx_call_parameters(R) ::= xx_call_parameter(P) . {
	R = xx_ret_list(NULL, P);
}

/* func(expr) */
xx_call_parameter(R) ::= xx_common_expr(E) . {
	R = xx_ret_call_parameter(NULL, E, status->scanner_state, 0);
}

/* func(name: expr) */
xx_call_parameter(R) ::= IDENTIFIER(I) COLON xx_common_expr(E) . {
	R = xx_ret_call_parameter(I, E, status->scanner_state, 0);
}

/* func(&expr) */
xx_call_parameter(R) ::= BITWISE_AND xx_common_expr(E) . {
	R = xx_ret_call_parameter(NULL, E, status->scanner_state, 1);
}

/* func(name: &expr) */
xx_call_parameter(R) ::= IDENTIFIER(I) COLON BITWISE_AND  xx_common_expr(E) . {
	R = xx_ret_call_parameter(I, E, status->scanner_state, 0);
}

/** empty closure function () { } **/
xx_common_expr(R) ::= FUNCTION PARENTHESES_OPEN PARENTHESES_CLOSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_expr("closure", NULL, NULL, NULL, status->scanner_state);
}

/** function() { ... }*/
xx_common_expr(R) ::= FUNCTION PARENTHESES_OPEN PARENTHESES_CLOSE BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_expr("closure", NULL, S, NULL, status->scanner_state);
}

/** function(a, b, c) { }*/
xx_common_expr(R) ::= FUNCTION PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE BRACKET_OPEN BRACKET_CLOSE . {
	R = xx_ret_expr("closure", L, NULL, NULL, status->scanner_state);
}

/** function(a, b, c) { ... }*/
xx_common_expr(R) ::= FUNCTION PARENTHESES_OPEN xx_parameter_list(L) PARENTHESES_CLOSE BRACKET_OPEN xx_statement_list(S) BRACKET_CLOSE . {
	R = xx_ret_expr("closure", L, S, NULL, status->scanner_state);
}

xx_array_list(R) ::= xx_array_list(L) COMMA xx_array_item(I) . {
	R = xx_ret_list(L, I);
}

xx_array_list(R) ::= xx_array_item(I) . {
	R = xx_ret_list(NULL, I);
}

xx_array_item(R) ::= xx_array_key(K) COLON xx_array_value(V) . {
	R = xx_ret_array_item(K, V, status->scanner_state);
}

xx_array_item(R) ::= xx_array_value(V) . {
	R = xx_ret_array_item(NULL, V, status->scanner_state);
}

xx_array_key(R) ::= CONSTANT(I) . {
	R = xx_ret_literal(XX_T_CONSTANT, I, status->scanner_state);
}

xx_array_key(R) ::= IDENTIFIER(I) . {
	R = xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state);
}

xx_array_key(R) ::= STRING(S) . {
	R = xx_ret_literal(XX_T_STRING, S, status->scanner_state);
}

xx_array_key(R) ::= INTEGER(I) . {
	R = xx_ret_literal(XX_T_INTEGER, I, status->scanner_state);
}

xx_array_value(R) ::= xx_common_expr(E) . {
	R = E;
}

/** xx_literal_expr */
xx_literal_expr(R) ::= INTEGER(I) . {
	R = xx_ret_literal(XX_T_INTEGER, I, status->scanner_state);
}

xx_literal_expr(R) ::= CHAR(C) . {
	R = xx_ret_literal(XX_T_CHAR, C, status->scanner_state);
}

xx_literal_expr(R) ::= STRING(S) . {
	R = xx_ret_literal(XX_T_STRING, S, status->scanner_state);
}

xx_literal_expr(R) ::= DOUBLE(D) . {
	R = xx_ret_literal(XX_T_DOUBLE, D, status->scanner_state);
}

xx_literal_expr(R) ::= NULL . {
	R = xx_ret_literal(XX_T_NULL, NULL, status->scanner_state);
}

xx_literal_expr(R) ::= FALSE . {
	R = xx_ret_literal(XX_T_FALSE, NULL, status->scanner_state);
}

xx_literal_expr(R) ::= TRUE . {
	R = xx_ret_literal(XX_T_TRUE, NULL, status->scanner_state);
}

xx_literal_expr(R) ::= IDENTIFIER(V) DOUBLECOLON CONSTANT(I) . {
	R = xx_ret_expr("static-constant-access", xx_ret_literal(XX_T_IDENTIFIER, V, status->scanner_state), xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state), NULL, status->scanner_state);
}

xx_literal_expr(R) ::= CONSTANT(I) . {
	R = xx_ret_literal(XX_T_CONSTANT, I, status->scanner_state);
}

xx_literal_expr(R) ::= SBRACKET_OPEN SBRACKET_CLOSE . {
	R = xx_ret_expr("empty-array", NULL, NULL, NULL, status->scanner_state);
}

xx_literal_expr(R) ::= SBRACKET_OPEN xx_literal_array_list(L) SBRACKET_CLOSE . {
	R = xx_ret_expr("array", L, NULL, NULL, status->scanner_state);
}

xx_literal_array_list(R) ::= xx_literal_array_list(L) COMMA xx_literal_array_item(I) . {
	R = xx_ret_list(L, I);
}

xx_literal_array_list(R) ::= xx_literal_array_item(I) . {
	R = xx_ret_list(NULL, I);
}

xx_literal_array_item(R) ::= xx_literal_array_key(K) COLON xx_literal_array_value(V) . {
	R = xx_ret_array_item(K, V, status->scanner_state);
}

xx_literal_array_item(R) ::= xx_literal_array_value(V) . {
	R = xx_ret_array_item(NULL, V, status->scanner_state);
}

xx_literal_array_key(R) ::= IDENTIFIER(I) . {
	R = xx_ret_literal(XX_T_IDENTIFIER, I, status->scanner_state);
}

xx_literal_array_key(R) ::= STRING(S) . {
	R = xx_ret_literal(XX_T_STRING, S, status->scanner_state);
}

xx_literal_array_key(R) ::= INTEGER(I) . {
	R = xx_ret_literal(XX_T_INTEGER, I, status->scanner_state);
}

xx_literal_array_value(R) ::= xx_literal_expr(E) . {
	R = E;
}

xx_eval_expr(R) ::= xx_common_expr(E) . {
	R = E;
}

xx_comment(R) ::= COMMENT(C) . {
	R = xx_ret_comment(C, status->scanner_state);
}

xx_cblock(R) ::= CBLOCK(C) . {
	R = xx_ret_cblock(C, status->scanner_state);
}
